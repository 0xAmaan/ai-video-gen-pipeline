{
  "version": 3,
  "sources": ["../../../workers/r2-proxy.ts"],
  "sourceRoot": "/Users/caseymanos/GauntletAI/ai-video-gen-pipeline/.wrangler/tmp/deploy-6db8VC",
  "sourcesContent": ["type R2Range = { offset: number; length?: number };\n\ntype R2ObjectBody = {\n  size: number;\n  body: ReadableStream | null;\n  writeHttpMetadata: (headers: Headers) => void;\n  httpEtag: string;\n  httpMetadata?: Record<string, string>;\n  customMetadata?: Record<string, string>;\n  range?: { offset: number; end?: number; length?: number };\n};\n\ntype R2Bucket = {\n  get: (key: string, options?: { range?: R2Range }) => Promise<R2ObjectBody | null>;\n  put: (key: string, value: BodyInit, options?: any) => Promise<any>;\n};\n\nexport interface Env {\n  R2_BUCKET: R2Bucket;\n  AUTH_TOKEN?: string;\n  ALLOWED_ORIGINS?: string;\n}\n\ntype RangeShape = { offset: number; length?: number };\n\nconst json = (body: unknown, init: ResponseInit = {}) =>\n  new Response(JSON.stringify(body), {\n    ...init,\n    headers: {\n      \"content-type\": \"application/json\",\n      ...init.headers,\n    },\n  });\n\nexport default {\n  async fetch(request: Request, env: Env): Promise<Response> {\n    const url = new URL(request.url);\n\n    // CORS preflight\n    if (request.method === \"OPTIONS\") {\n      return withCors(new Response(null, { status: 204 }), env);\n    }\n\n    if (url.pathname.startsWith(\"/asset/\") && (request.method === \"GET\" || request.method === \"HEAD\")) {\n      return withCors(await serveAsset(request, env, url.pathname.replace(\"/asset/\", \"\")), env);\n    }\n\n    if (url.pathname === \"/ingest\" && request.method === \"POST\") {\n      if (!isAuthorized(request, env)) {\n        return withCors(new Response(\"Unauthorized\", { status: 401 }), env);\n      }\n      return withCors(await ingestToR2(request, env), env);\n    }\n\n    return new Response(\"Not found\", { status: 404 });\n  },\n};\n\nasync function serveAsset(request: Request, env: Env, key: string): Promise<Response> {\n  if (!key) {\n    return json({ error: \"Missing key\" }, { status: 400 });\n  }\n\n  // Keys arrive URL-encoded (e.g., videos%2Ffile.mp4); decode once for R2 lookup.\n  const objectKey = (() => {\n    try {\n      return decodeURIComponent(key);\n    } catch {\n      return key;\n    }\n  })();\n\n  try {\n    // Always serve the full object to avoid Cloudflare rewriting partial responses to 200.\n    const object = await env.R2_BUCKET.get(objectKey);\n    if (!object || !object.body) {\n      return json({ error: \"Not found\" }, { status: 404 });\n    }\n\n    const responseHeaders = new Headers();\n    responseHeaders.set(\"accept-ranges\", \"bytes\");\n    responseHeaders.set(\"x-proxy-version\", \"2025-11-22-02\");\n    responseHeaders.set(\"cache-control\", \"private, no-store, no-cache, must-revalidate\");\n    const contentType =\n      object.httpMetadata?.contentType ?? object.customMetadata?.contentType ?? \"application/octet-stream\";\n    responseHeaders.set(\"content-type\", contentType);\n\n    responseHeaders.set(\"content-length\", object.size.toString());\n    console.log(\"serveAsset full\", { key: objectKey, size: object.size, status: 200 });\n    if (request.method === \"HEAD\") {\n      return new Response(null, { status: 200, headers: responseHeaders });\n    }\n    return new Response(object.body, { status: 200, headers: responseHeaders });\n  } catch (error) {\n    console.error(\"R2 proxy error\", error);\n    return json({ error: \"Proxy failure\" }, { status: 502 });\n  }\n}\n\nasync function ingestToR2(request: Request, env: Env): Promise<Response> {\n  const payload = await safeJson(request);\n  if (!payload || typeof payload.sourceUrl !== \"string\" || typeof payload.key !== \"string\") {\n    return json({ error: \"Expected body: { sourceUrl, key }\" }, { status: 400 });\n  }\n\n  const upstream = await fetch(payload.sourceUrl);\n  if (!upstream.ok || !upstream.body) {\n    return json({ error: `Upstream fetch failed (${upstream.status})` }, { status: 502 });\n  }\n\n  const contentLength = upstream.headers.get(\"content-length\");\n  const parsedLength = contentLength ? Number.parseInt(contentLength, 10) : NaN;\n  if (!Number.isFinite(parsedLength) || parsedLength <= 0) {\n    return json({ error: \"Content-Length required for streaming ingest\" }, { status: 400 });\n  }\n\n  const contentType = upstream.headers.get(\"content-type\") ?? undefined;\n  await env.R2_BUCKET.put(payload.key, upstream.body, {\n    httpMetadata: contentType ? { contentType } : undefined,\n    customMetadata: {\n      sourceUrl: payload.sourceUrl,\n    },\n    onlyIf: { doesNotExist: true },\n    // Explicit object size prevents Workers from buffering the stream.\n    objectSize: parsedLength,\n  });\n\n  return json({ ok: true, key: payload.key });\n}\n\nfunction parseRange(header: string): RangeShape | null {\n  // Example: bytes=0-1023 or bytes=1024-\n  const match = /^bytes=(\\d+)-(\\d+)?$/i.exec(header.trim());\n  if (!match) return null;\n  const start = Number.parseInt(match[1] ?? \"0\", 10);\n  const end = match[2] ? Number.parseInt(match[2], 10) : undefined;\n  if (Number.isNaN(start)) return null;\n  if (end !== undefined) {\n    return { offset: start, length: Math.max(0, end - start + 1) };\n  }\n  return { offset: start };\n}\n\nasync function safeJson(request: Request): Promise<any | null> {\n  try {\n    return await request.json();\n  } catch {\n    return null;\n  }\n}\n\nfunction isAuthorized(request: Request, env: Env): boolean {\n  if (!env.AUTH_TOKEN) return true;\n  const header = request.headers.get(\"authorization\");\n  return header === `Bearer ${env.AUTH_TOKEN}`;\n}\n\nfunction withCors(response: Response, env: Env): Response {\n  const allowed = env.ALLOWED_ORIGINS?.split(\",\").map((v) => v.trim()) ?? [];\n  const origin = allowed.length ? allowed : [\"*\"];\n\n  const headers = new Headers(response.headers);\n  headers.set(\"access-control-allow-origin\", origin.join(\",\"));\n  headers.set(\"access-control-allow-methods\", \"GET,POST,OPTIONS\");\n  headers.set(\"access-control-allow-headers\", \"authorization,content-type,range\");\n  headers.set(\"access-control-expose-headers\", \"content-range,accept-ranges\");\n  // Required when the client is using COEP/COOP; allows media to be fetched cross-origin.\n  headers.set(\"cross-origin-resource-policy\", \"cross-origin\");\n  return new Response(response.body, { ...response, headers });\n}\n"],
  "mappings": "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",
  "names": []
}
